<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VoidSentry Documentation</title>
    <link rel="stylesheet" href="style/style.css">
</head>
<body>
    <div class="container">
        <!-- Left Navigation -->
        <nav class="sidebar">
            <div class="logo">
                <h1>VoidSentry</h1>
                <p class="version">v0.0.7</p>
                <div class="logo-links">
                    <a href="https://github.com/Elentium/VoidSentry" target="_blank" class="logo-link">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/></svg>
                        GitHub
                    </a>
                    <a href="https://wally.run/package/elentium/voidsentry" target="_blank" class="logo-link">
                        <svg viewBox="0 0 24 24" width="20" height="20" fill="currentColor"><path d="M21 16.5c0 .38-.21.71-.53.88l-7.9 4.44c-.16.12-.36.18-.57.18s-.41-.06-.57-.18l-7.9-4.44A.991.991 0 0 1 3 16.5v-9c0-.38.21-.71.53-.88l7.9-4.44c.16-.12.36-.18.57-.18s.41.06.57.18l7.9 4.44c.32.17.53.5.53.88v9zM12 4.15L5 8.09v7.82l7 3.94l7-3.94V8.09l-7-3.94z"/></svg>
                        Wally
                    </a>
                </div>
            </div>
            <ul class="nav-menu">
                <li><button class="nav-btn active" data-page="overview">Overview</button></li>
                <li><button class="nav-btn" data-page="api">API Reference</button></li>
                <li><button class="nav-btn" data-page="practices">Best Practices</button></li>
                <li><button class="nav-btn" data-page="credits">Credits & Logs</button></li>
            </ul>
        </nav>

        <!-- Main Content Area -->
        <main class="content">
            <!-- Page 1: Overview -->
            <section id="overview" class="page active">
                <div class="page-content">
                    <h1 class="page-title">VoidSentry</h1>
                    <p class="tagline">High-performance buffer serialization for Roblox</p>

                    <div class="section">
                        <h2>Purpose</h2>
                        <p>VoidSentry is a powerful, low-level buffer serializer designed for efficient data transmission in Roblox games. It provides both static (schema-based) and dynamic (schemaless) serialization with support for a wide range of data types.</p>
                        
                        <div class="feature-grid">
                            <div class="feature-card">
                                <h3>üöÄ High Performance</h3>
                                <p>Native optimizations and efficient buffer operations for maximum speed</p>
                            </div>
                            <div class="feature-card">
                                <h3>üì¶ Zero Dependencies</h3>
                                <p>Standalone library with no external requirements</p>
                            </div>
                            <div class="feature-card">
                                <h3>üéØ Type Safe</h3>
                                <p>Full strict-mode Luau type annotations for better IDE support</p>
                            </div>
                            <div class="feature-card">
                                <h3>‚ö° Flexible</h3>
                                <p>30+ built-in types including primitives, Roblox types, and complex structures</p>
                            </div>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Installation</h2>
                        <div class="code-block">
                            <h3>Wally: </h3>
                            <pre><code>[dependencies]
VoidSentry = "elentium/voidsentry@0.0.7"</code></pre>
                             <h3> Direct(rbxm): </h3>
                               <p>find the VoidSentry.rbxm in roblox-direct file in repo</p>  
                        </div>
                        <p>Then run: <code class="inline-code">wally install</code></p>
                    </div>

                    <div class="section">
                        <h2>Quick Start</h2>
                        
                        <h3>Static Serializer (Recommended)</h3>
                        <div class="code-block">
                            <pre><code>--!strict
local VoidSentry = require(ReplicatedStorage.Packages.VoidSentry)
local Types = VoidSentry.Types

-- Create a serializer with a fixed schema
local Serializer = VoidSentry.Static.new(
    nil, -- No compression
    Types.Int32,
    Types.String,
    Types.Struct({
        Hello = Types.String,
        World = Types.Int32,
    })
)

-- Serialize data
local b = Serializer:serialize(nil, 42, "Hello, world!", {
    Hello = "hi",
    World = 999,
})

-- Deserialize data
local int, str, struct = Serializer:deserialize(nil, b)</code></pre>
                        </div>

                        <h3>Dynamic Serializer</h3>
                        <div class="code-block">
                            <pre><code>local VoidSentry = require(ReplicatedStorage.Packages.VoidSentry)
local Dynamic = VoidSentry.Dynamic

-- No schema required!
local buffer = Dynamic.serialize(
    nil, -- No compression
    nil, -- No offset
    42,
    "Dynamic serialization",
    Vector3.new(10, 20, 30),
    true
)

-- Deserialize automatically
local int, str, vec, bool = Dynamic.deserialize(nil, nil, buffer)</code></pre>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Performance Benchmarks</h2>
                        <p class="note">* All benchmarks performed with 2000 iterations per test on standard Roblox hardware. Results show average time per operation.</p>
                        
                        <h3>Static Serializer Performance</h3>
                        <div class="benchmark-table-container">
                            <table class="benchmark-table">
                                <thead>
                                    <tr>
                                        <th>Test Case</th>
                                        <th>Serialize (avg)</th>
                                        <th>Deserialize (avg)</th>
                                        <th>Total (avg)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td>Simple Types (Int32, String, Bool)</td><td>0.000959 ms</td><td>0.000443 ms</td><td>0.001402 ms</td></tr>
                                    <tr><td>Vector Types (Vector3, Vector3F24)</td><td>0.001292 ms</td><td>0.000431 ms</td><td>0.001723 ms</td></tr>
                                    <tr><td>Array Types (Array&lt;Int32&gt;)</td><td>0.001149 ms</td><td>0.000563 ms</td><td>0.001712 ms</td></tr>
                                    <tr><td>Struct Types (PlayerData)</td><td>0.001086 ms</td><td>0.000782 ms</td><td>0.001868 ms</td></tr>
                                    <tr><td>Complex Nested Types</td><td>0.002128 ms</td><td>0.001329 ms</td><td>0.003457 ms</td></tr>
                                    <tr><td>With Compression (Level 5)</td><td>0.002118 ms</td><td>0.001450 ms</td><td>0.003568 ms</td></tr>
                                </tbody>
                            </table>
                        </div>

                        <h3>Dynamic Serializer Performance</h3>
                        <div class="benchmark-table-container">
                            <table class="benchmark-table">
                                <thead>
                                    <tr>
                                        <th>Test Case</th>
                                        <th>Serialize (avg)</th>
                                        <th>Deserialize (avg)</th>
                                        <th>Total (avg)</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td>Simple Types (Int32, String, Bool)</td><td>0.002071 ms</td><td>0.003448 ms</td><td>0.005519 ms</td></tr>
                                    <tr><td>Vector Types (Vector3)</td><td>0.001214 ms</td><td>0.001489 ms</td><td>0.002703 ms</td></tr>
                                    <tr><td>Array Types (Mixed Array)</td><td>0.012221 ms</td><td>0.009558 ms</td><td>0.021779 ms</td></tr>
                                    <tr><td>Struct Types (PlayerData as Table)</td><td>0.014557 ms</td><td>0.012684 ms</td><td>0.027241 ms</td></tr>
                                    <tr><td>Complex Nested Types</td><td>0.017743 ms</td><td>0.019277 ms</td><td>0.037020 ms</td></tr>
                                    <tr><td>Mixed Types (Multiple Types)</td><td>0.011130 ms</td><td>0.013152 ms</td><td>0.024282 ms</td></tr>
                                    <tr><td>With Compression (Level 5)</td><td>0.003054 ms</td><td>0.004565 ms</td><td>0.007619 ms</td></tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="benchmark-grid">
                            <div class="benchmark-card">
                                <h3>Performance Comparison</h3>
                                <p class="benchmark-number">4.59x</p>
                                <p class="benchmark-label">faster (Static vs Dynamic)</p>
                                <p class="benchmark-desc">Simple types benchmark shows Static serializer is ~4.6x faster</p>
                            </div>
                            <div class="benchmark-card">
                                <h3>Static Simple Types</h3>
                                <p class="benchmark-number">0.001174 ms</p>
                                <p class="benchmark-label">average per operation</p>
                                <p class="benchmark-desc">Serialize + Deserialize combined</p>
                            </div>
                            <div class="benchmark-card">
                                <h3>Dynamic Simple Types</h3>
                                <p class="benchmark-number">0.005392 ms</p>
                                <p class="benchmark-label">average per operation</p>
                                <p class="benchmark-desc">Serialize + Deserialize combined</p>
                            </div>
                            <div class="benchmark-card">
                                <h3>Overhead</h3>
                                <p class="benchmark-number">0.004218 ms</p>
                                <p class="benchmark-label">additional time per operation</p>
                                <p class="benchmark-desc">Dynamic adds type inference overhead</p>
                            </div>
                        </div>

                        <div class="note-box">
                            <h4>üí° Key Insights</h4>
                            <ul>
                                <li><strong>Static serializer</strong> is significantly faster (4.59x) for simple types</li>
                                <li><strong>Dynamic serializer</strong> overhead increases dramatically with complex nested structures</li>
                                <li><strong>Compression</strong> adds overhead but can be beneficial for larger datasets</li>
                                <li><strong>Deserialization</strong> is generally faster than serialization for Static, but slower for Dynamic due to type inference</li>
                                <li>Use <strong>Static serializer</strong> when schema is known for optimal performance</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Page 2: API Reference -->
            <section id="api" class="page">
                <div class="page-content">
                    <h1 class="page-title">API Reference</h1>

                    <div class="section">
                        <h2>Static Serializer</h2>
                        
                        <div class="api-item">
                            <h3 class="api-signature">VoidSentry.Static.new(compressionLevel: number?, ...TypeNode): StaticObject</h3>
                            <p>Creates a new static serializer with a fixed schema.</p>
                            <div class="api-params">
                                <strong>Parameters:</strong>
                                <ul>
                                    <li><code>compressionLevel</code> (optional): Zstd compression level (-7 to 22, or <code>nil</code> for no compression)</li>
                                    <li><code>...TypeNode</code>: Variable number of type nodes defining the schema</li>
                                </ul>
                                <strong>Returns:</strong> A <code>StaticObject</code> with <code>serialize</code> and <code>deserialize</code> methods
                            </div>
                        </div>

                        <div class="api-item">
                            <h3 class="api-signature">StaticObject:serialize(offset: number?, ...values): buffer</h3>
                            <p>Serializes data according to the schema.</p>
                            <div class="api-params">
                                <strong>Parameters:</strong>
                                <ul>
                                    <li><code>offset</code> (optional): Starting byte offset (reserves <code>offset</code> bytes at the beginning for custom metadata)</li>
                                    <li><code>...values</code>: Values matching the schema types</li>
                                </ul>
                                <strong>Returns:</strong> A buffer containing the serialized data
                            </div>
                        </div>

                        <div class="api-item">
                            <h3 class="api-signature">StaticObject:deserialize(offset: number?, buffer: buffer): ...values</h3>
                            <p>Deserializes data from a buffer.</p>
                            <div class="api-params">
                                <strong>Parameters:</strong>
                                <ul>
                                    <li><code>offset</code> (optional): Starting byte offset to read from</li>
                                    <li><code>buffer</code>: The buffer to deserialize</li>
                                </ul>
                                <strong>Returns:</strong> One or multiple values matching the schema
                            </div>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Dynamic Serializer</h2>
                        
                        <div class="api-item">
                            <h3 class="api-signature">VoidSentry.Dynamic.serialize(compressionLevel: number?, offset: number?, ...values): buffer</h3>
                            <p>Serializes data with automatic type inference.</p>
                            <div class="api-params">
                                <strong>Parameters:</strong>
                                <ul>
                                    <li><code>compressionLevel</code> (optional): Zstd compression level (-7 to 22)</li>
                                    <li><code>offset</code> (optional): Starting byte offset</li>
                                    <li><code>...values</code>: Any serializable values</li>
                                </ul>
                                <strong>Returns:</strong> A buffer with type information and data
                            </div>
                        </div>

                        <div class="api-item">
                            <h3 class="api-signature">VoidSentry.Dynamic.deserialize(compressionLevel: number?, offset: number?, buffer: buffer): ...values</h3>
                            <p>Deserializes data with embedded type information.</p>
                            <div class="api-params">
                                <strong>Parameters:</strong>
                                <ul>
                                    <li><code>compressionLevel</code> (optional): Must match serialization compression level</li>
                                    <li><code>offset</code> (optional): Starting byte offset</li>
                                    <li><code>buffer</code>: The buffer to deserialize</li>
                                </ul>
                                <strong>Returns:</strong> All values that were serialized
                            </div>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Available Types</h2>

                        <div class="types-section">
                            <h3>Numeric Types</h3>
                            <table class="types-table">
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Description</th>
                                        <th>Size</th>
                                        <th>Range</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td><code>Types.Int8</code></td><td>Signed 8-bit integer</td><td>1 byte</td><td>-128 to 127</td></tr>
                                    <tr><td><code>Types.UInt8</code></td><td>Unsigned 8-bit integer</td><td>1 byte</td><td>0 to 255</td></tr>
                                    <tr><td><code>Types.Int16</code></td><td>Signed 16-bit integer</td><td>2 bytes</td><td>-32,768 to 32,767</td></tr>
                                    <tr><td><code>Types.UInt16</code></td><td>Unsigned 16-bit integer</td><td>2 bytes</td><td>0 to 65,535</td></tr>
                                    <tr><td><code>Types.Int32</code></td><td>Signed 32-bit integer</td><td>4 bytes</td><td>-2¬≥¬π to 2¬≥¬π-1</td></tr>
                                    <tr><td><code>Types.UInt32</code></td><td>Unsigned 32-bit integer</td><td>4 bytes</td><td>0 to 2¬≥¬≤-1</td></tr>
                                    <tr><td><code>Types.Float32</code></td><td>32-bit floating point</td><td>4 bytes</td><td>IEEE 754 single precision</td></tr>
                                    <tr><td><code>Types.Float64</code></td><td>64-bit floating point</td><td>8 bytes</td><td>IEEE 754 double precision</td></tr>
                                    <tr><td><code>Types.Float24</code></td><td>24-bit floating point</td><td>3 bytes</td><td>Reduced precision (custom format)</td></tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="types-section">
                            <h3>String Types</h3>
                            <table class="types-table">
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Description</th>
                                        <th>Max Size</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td><code>Types.String</code></td><td>Standard string</td><td>65,535 + 2 bytes (16-bit length prefix)</td></tr>
                                    <tr><td><code>Types.StringTiny</code></td><td>Compact string</td><td>255 + 1 byte (8-bit length prefix)</td></tr>
                                    <tr><td><code>Types.StringFixed(len)</code></td><td>Fixed length string</td><td>User-defined length</td></tr>
                                    <tr><td><code>Types.StringNullTerminated</code></td><td>Null-terminated string (C-style)</td><td>Unlimited</td></tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="types-section">
                            <h3>Boolean & Special Types</h3>
                            <ul class="types-list">
                                <li><code>Types.Bool</code> - Boolean value (1 byte)</li>
                                <li><code>Types.Void</code> - Empty table (0 bytes)</li>
                                <li><code>Types.Nil</code> - Nil value (0 bytes)</li>
                                <li><code>Types.Any</code> - Any type (dynamic, includes type information)</li>
                            </ul>
                        </div>

                        <div class="types-section">
                            <h3>Roblox Types</h3>
                            <table class="types-table">
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Description</th>
                                        <th>Size</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td><code>Types.Vector3</code></td><td>Full precision Vector3</td><td>12 bytes</td></tr>
                                    <tr><td><code>Types.Vector3F24</code></td><td>Reduced precision Vector3</td><td>9 bytes</td></tr>
                                    <tr><td><code>Types.Vector3int16</code></td><td>Integer Vector3</td><td>6 bytes</td></tr>
                                    <tr><td><code>Types.Vector2</code></td><td>Full precision Vector2</td><td>8 bytes</td></tr>
                                    <tr><td><code>Types.Vector2F24</code></td><td>Reduced precision Vector2</td><td>6 bytes</td></tr>
                                    <tr><td><code>Types.Vector2int16</code></td><td>Integer Vector2</td><td>4 bytes</td></tr>
                                    <tr><td><code>Types.Vector</code></td><td>Full precision vector (luau native vector type)</td><td>12 bytes</td></tr>
                                    <tr><td><code>Types.VectorF24</code></td><td>Reduced precision vector</td><td>9 bytes</td></tr>
                                    <tr><td><code>Types.VectorInt16</code></td><td>Integer vector</td><td>6 bytes</td></tr>
                                    <tr><td><code>Types.CFrame</code></td><td>Full precision CFrame</td><td>48 bytes</td></tr>
                                    <tr><td><code>Types.CFrameQ</code></td><td>Quaternion CFrame</td><td>28 bytes</td></tr>
                                    <tr><td><code>Types.Color3</code></td><td>RGB color</td><td>3 bytes</td></tr>
                                    <tr><td><code>Types.Enum(EnumType)</code></td><td>Enum value (requires Enum parameter)</td><td>2 bytes</td></tr>
                                    <tr><td><code>Types.Instance</code></td><td>Roblox Instance</td><td>Variable(Struct)</td></tr>
                                </tbody>
                            </table>
                        </div>

                        <div class="types-section">
                            <h3>Collection Types</h3>
                            <table class="types-table">
                                <thead>
                                    <tr>
                                        <th>Type</th>
                                        <th>Description</th>
                                        <th>Parameters</th>
                                        <th>Max Size</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td><code>Types.Array(elementType)</code></td><td>Variable-size array</td><td>Element type</td><td>65,535 elements</td></tr>
                                    <tr><td><code>Types.ArrayTiny(elementType)</code></td><td>Compact array</td><td>Element type</td><td>255 elements</td></tr>
                                    <tr><td><code>Types.ArrayFixed(elementType, len)</code></td><td>Fixed-size array</td><td>Element type, length</td><td>User-defined</td></tr>
                                    <tr><td><code>Types.Map(keyType, valueType)</code></td><td>Variable-size map</td><td>Key type, value type</td><td>65,535 entries</td></tr>
                                    <tr><td><code>Types.MapFixed(keyType, valueType, len)</code></td><td>Fixed-size map</td><td>Key type, value type, length</td><td>User-defined</td></tr>
                                    <tr><td><code>Types.Struct({field = Type, ...})</code></td><td>Fixed structure with named fields</td><td>Schema object</td><td>Fixed fields</td></tr>
                                    <tr><td><code>Types.Optional(type)</code></td><td>Nullable type</td><td>Base type</td><td>Same as base type + 1 byte</td></tr>
                                    <tr><td><code>Types.BoolPacked</code></td><td>Array of exactly 8 booleans</td><td>None</td><td>8 booleans (1 byte)</td></tr>
                                    <tr><td><code>Types.Bits._8(count)</code></td><td>Array of 8-bit values</td><td>Count</td><td>User-defined</td></tr>
                                    <tr><td><code>Types.Bits._16(count)</code></td><td>Array of 16-bit values</td><td>Count</td><td>User-defined</td></tr>
                                    <tr><td><code>Types.Bits._32(count)</code></td><td>Array of 32-bit values</td><td>Count</td><td>User-defined</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Instance Type</h2>
                        
                        <div class="api-item">
                            <h3 class="api-signature">Types.Instance</h3>
                            <p>Instances are serialized like structs. In order for the serializer to recognize an Instance's ClassName, it must be predefined in <code>serialize_data.luau</code> as a struct schema.</p>
                            <div class="api-params">
                                <strong>How it works:</strong>
                                <ul>
                                    <li>Each Instance ClassName you want to serialize must have a corresponding struct definition in <code>serialize_data.luau</code></li>
                                    <li>The struct defines which properties of the Instance will be serialized</li>
                                    <li>Only the properties defined in the struct schema will be included in serialization</li>
                                </ul>
                                <strong>Example:</strong>
                            </div>
                            <div class="code-block">
                                <pre><code>-- In serialize_data.luau, define the Instance schema:
-- Example for a "Part" class
Part = Types.Struct({
    Name = Types.String,
    Position = Types.Vector3,
    Size = Types.Vector3,
    Color = Types.Color3,
    Anchored = Types.Bool,
})

-- Then use Types.Instance in your serializer:
local Serializer = VoidSentry.Static.new(nil, Types.Instance("Part"))

-- Serialize the Instance
local part = workspace.MyPart
local buffer = Serializer:serialize(nil, part)</code></pre>
                            </div>
                            <div class="note-box">
                                <h4>üí° Important</h4>
                                <ul>
                                    <li>The ClassName must exactly match the struct name in <code>serialize_data.luau</code></li>
                                    <li>Undefined ClassNames will cause an error during serialization</li>
                                    <li>Only properties defined in the struct will be serialized ‚Äî other properties are ignored</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Page 3: Best Practices -->
            <section id="practices" class="page">
                <div class="page-content">
                    <h1 class="page-title">Best Practices & Warnings</h1>

                    <div class="section">
                        <h2>Best Practices</h2>

                        <div class="practice-item">
                            <h3>‚úÖ Use Static Serializer When Possible</h3>
                            <p>The static serializer is significantly faster (3x+) than dynamic serialization because it doesn't need to infer types at runtime. Always use static serialization when you know your data structure ahead of time.</p>
                            <div class="code-block">
                                <pre><code>-- ‚úÖ Good: Static serializer
local Serializer = VoidSentry.Static.new(nil, Types.Int32, Types.String)

-- ‚ö†Ô∏è Only use dynamic when structure is unknown
local buffer = VoidSentry.Dynamic.serialize(nil, nil, data)</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h3>‚úÖ Choose Appropriate Types</h3>
                            <p>Use the smallest type that fits your data to reduce bandwidth and improve performance.</p>
                            <div class="code-block">
                                <pre><code>-- ‚úÖ Good: Use Int16 for small numbers
Types.Int16  -- -32,768 to 32,767

-- ‚ùå Bad: Using Int32 for small numbers
Types.Int32  -- Unnecessary overhead

-- ‚úÖ Good: Use Vector3F24 for approximate positions
Types.Vector3F24  -- 9 bytes vs 12 bytes

-- ‚úÖ Good: Use StringTiny for short strings
Types.StringTiny  -- For strings ‚â§ 255 characters</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h3>‚úÖ Reuse Serializers</h3>
                            <p>Create serializer objects once and reuse them. Don't create new serializers on every serialization call.</p>
                            <div class="code-block">
                                <pre><code>-- ‚úÖ Good: Create once, reuse
local PlayerSerializer = VoidSentry.Static.new(nil, Types.Struct({...}))

for _, player in players do
    local b = PlayerSerializer:serialize(nil, player)
    -- Send buffer
end

-- ‚ùå Bad: Creating new serializer each time
for _, player in players do
    local serializer = VoidSentry.Static.new(nil, Types.Struct({...}))
    local b = serializer:serialize(nil, player)
end</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h3>‚úÖ Batch Serialization</h3>
                            <p>Serialize multiple values at once rather than separately to reduce overhead.</p>
                            <div class="code-block">
                                <pre><code>-- ‚úÖ Good: Serialize together
local b = Serializer:serialize(nil, intValue, stringValue, structValue)

-- ‚ùå Bad: Multiple serializations
local b1 = Serializer:serialize(nil, intValue)
local b2 = Serializer:serialize(nil, stringValue)
local b3 = Serializer:serialize(nil, structValue)</code></pre>
                            </div>
                        </div>

                        <div class="practice-item">
                            <h3>‚úÖ Compression Trade-offs</h3>
                            <p>Compression reduces bandwidth but increases CPU usage. Use compression for large data or slow connections.</p>
                            <ul>
                                <li><strong>-7 to 3:</strong> Fast compression, lower ratio (good for real-time)</li>
                                <li><strong>5 to 10:</strong> Balanced (recommended for most cases)</li>
                                <li><strong>15 to 22:</strong> Maximum compression, slower (good for storage)</li>
                            </ul>
                        </div>

                        <div class="practice-item">
                            <h3>‚úÖ Validate Data Types</h3>
                            <p>Ensure your data matches the expected types before serialization to avoid runtime errors.</p>
                            <div class="code-block">
                                <pre><code>-- ‚úÖ Good: Type checking
if typeof(value) == "number" and value >= 0 and value <= 255 then
    local b = Serializer:serialize(nil, value)
end</code></pre>
                            </div>
                        </div>
                    </div>

                    <div class="section">
                        <h2>‚ö†Ô∏è Warnings</h2>

                        <div class="warning-item">
                            <h3>‚ö†Ô∏è Schema Mismatches</h3>
                            <p><strong>Warning:</strong> If you modify your schema, old serialized buffers will be incompatible. Plan schema changes carefully or implement versioning.</p>
                            <div class="code-block">
                                <pre><code>-- Schema change breaks compatibility
-- Old: Types.Int32, Types.String
-- New: Types.Int32, Types.String, Types.Bool
-- Old buffers cannot be deserialized with new schema!</code></pre>
                            </div>
                        </div>

                        <div class="warning-item">
                            <h3>‚ö†Ô∏è Compression Usage Recommendations</h3>
                            <p><strong>Warning:</strong> Compression is not always beneficial. Use compression carefully based on your data characteristics.</p>
                            <ul>
                                <li><strong>Not recommended for small data:</strong> Compression overhead may exceed benefits for buffers under 1KB. The compression algorithm itself adds overhead that can make small buffers larger.</li>
                                <li><strong>Ineffective for unique data:</strong> Compression works best with repetitive patterns. If your data consists of mostly unique bytes (random or encrypted data), compression may actually increase the buffer size rather than reduce it.</li>
                                <li><strong>CPU vs Bandwidth trade-off:</strong> Compression reduces bandwidth usage but increases CPU usage for both serialization and deserialization. Consider your game's performance profile before enabling compression.</li>
                                <li><strong>Best for:</strong> Large structured data (>1KB) with repeated patterns, data sent infrequently, or when bandwidth is more constrained than CPU.</li>
                            </ul>
                            <div class="code-block">
                                <pre><code>-- ‚ùå Not recommended: Small data
local smallData = Serializer:serialize(nil, 42, "hello")  -- ~10 bytes
-- Compression adds overhead, may increase size

-- ‚úÖ Good: Large structured data
local largeData = Serializer:serialize(5, hugeTable, manyStrings)  -- 5KB+
-- Compression likely beneficial

-- ‚ùå Not recommended: Random/unique data
local encryptedData = Serializer:serialize(5, encryptedBuffer)
-- Random bytes don't compress well, may increase size</code></pre>
                            </div>
                        </div>

                        <div class="warning-item">
                            <h3>‚ö†Ô∏è Offset Usage</h3>
                            <p><strong>Warning:</strong> If you use an offset during serialization, you must use the same offset during deserialization.</p>
                            <div class="code-block">
                                <pre><code>-- ‚úÖ Correct: Same offset
local b = Serializer:serialize(10, data)
local result = Serializer:deserialize(10, b)

-- ‚ùå Wrong: Different offsets
local b = Serializer:serialize(10, data)
local result = Serializer:deserialize(0, b)  -- Will fail!</code></pre>
                            </div>
                        </div>

                        <div class="warning-item">
                            <h3>‚ö†Ô∏è Type Limits</h3>
                            <p><strong>Warning:</strong> Be aware of type limits to avoid runtime errors.</p>
                            <ul>
                                <li><code>StringTiny</code>: Max 255 characters</li>
                                <li><code>ArrayTiny</code>: Max 255 elements</li>
                                <li><code>String</code> / <code>Array</code>: Max 65,535 characters/elements</li>
                                <li>Numeric types have fixed ranges</li>
                            </ul>
                        </div>

                        <div class="warning-item">
                            <h3>‚ö†Ô∏è Enum Type Requirements</h3>
                            <p><strong>Warning:</strong> When using <code>Types.Enum</code>, you must provide the Enum type and ensure the value belongs to that Enum.</p>
                            <div class="code-block">
                                <pre><code>-- ‚úÖ Correct
local MaterialEnum = Types.Enum(Enum.Material)
local b = Serializer:serialize(nil, Enum.Material.Plastic)

-- ‚ùå Wrong: Type mismatch
local MaterialEnum = Types.Enum(Enum.Material)
local b = Serializer:serialize(nil, Enum.HumanoidStateType.Running)  -- Error!</code></pre>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Page 4: Credits & Logs -->
            <section id="credits" class="page">
                <div class="page-content">
                    <h1 class="page-title">Credits & Update Logs</h1>

                    <div class="section">
                        <h2>Credits</h2>
                        <div class="credits-card">
                            <h3>Author</h3>
                            <p><strong>IAMNOTULTRA3</strong> (a.k.a elentium/elite)</p>
                        </div>

                        <div class="credits-card">
                            <h3>License</h3>
                            <p>This project is licensed under the <strong>Apache 2.0 License</strong>.</p>
                            <p>See the LICENSE file for details.</p>
                        </div>

                        <div class="credits-card">
                            <h3>Repository</h3>
                            <p>Package: <code>elentium/voidsentry@0.0.7</code></p>
                            <p>Github: <code>https://github.com/Elentium/VoidSentry</code></p>
                        </div>

                        <div class="credits-card">
                            <h3>Support</h3>
                            <p>For questions, issues, or feature requests, please open an issue on the repository or contact the author.</p>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Changelog</h2>
                        
                        <div class="changelog-item latest">
                            <h3 class="version-badge">Version 0.0.7</h3>
                            <ul>
                                <li>Added Instance type</li>
                                <li>Reworked serializers(instead of making 2 iterations for serialization, it uses only one, by dynamically extending buffer when there is not enough space)</li>
                            </ul>
                        </div>

                        <div class="changelog-item">
                            <h3 class="version-badge">Version 0.0.6</h3>
                            <ul>
                                <li>Fixed default.project.json</li>
                            </ul>
                        </div>

                        <div class="changelog-item">
                            <h3 class="version-badge">Version 0.0.5</h3>
                            <ul>
                                <li>Created GitHub repo & documentation</li>
                                <li>Published the package</li>
                            </ul>
                        </div>

                        <div class="changelog-item">
                            <h3 class="version-badge">Version 0.0.4</h3>
                            <ul>
                                <li>Changed some type names (e.g., Short ‚Üí Int16)</li>
                            </ul>
                        </div>

                        <div class="changelog-item">
                            <h3 class="version-badge">Version 0.0.3</h3>
                            <ul>
                                <li>Fixed the way any type handled enums</li>
                                <li>Small optimizations</li>
                                <li>Better comments</li>
                            </ul>
                        </div>

                        <div class="changelog-item">
                            <h3 class="version-badge">Version 0.0.2</h3>
                            <ul>
                                <li>Improved README</li>
                                <li>Optimized Array, ArrayTiny, ArrayFixed types</li>
                                <li>Removed redundancy & inconsistencies</li>
                            </ul>
                        </div>

                        <div class="changelog-item">
                            <h3 class="version-badge">Version 0.0.1</h3>
                            <ul>
                                <li>Initial release</li>
                            </ul>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Contributing</h2>
                        <p>Contributions are welcome! Please feel free to submit issues or pull requests.</p>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        // Navigation functionality
        const navButtons = document.querySelectorAll('.nav-btn');
        const pages = document.querySelectorAll('.page');

        navButtons.forEach(button => {
            button.addEventListener('click', () => {
                const targetPage = button.getAttribute('data-page');

                // Remove active class from all buttons and pages
                navButtons.forEach(btn => btn.classList.remove('active'));
                pages.forEach(page => page.classList.remove('active'));

                // Add active class to clicked button and corresponding page
                button.classList.add('active');
                document.getElementById(targetPage).classList.add('active');

                // Scroll to top
                window.scrollTo(0, 0);
            });
        });
    </script>
</body>
</html>
